

===== Refactor Snapshot 2025-05-29T04:26:48.600196 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)
VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"
def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")
def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")
def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    upgrades = []
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades
def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")
def auto_refactor():
        logging.info("๐ ุขุบุงุฒ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู (Refactor)...")
        # ุดุจูโุณุงุฒ ุชุญูู ุงุณุชุงุชฺฉ ฺฉุฏ ู ุจูุจูุฏ ุณุงุฎุชุงุฑ ุขู
        time.sleep(1)
        # --- ุงุฑุชูุงูุง ุฌุฏุฏ: ุชุญูู ู ูพุดููุงุฏ ุฎูุฏฺฉุงุฑ ---
        # ฑ. ุจุฑุฑุณ ุฎุทูุท ุชฺฉุฑุงุฑ ู ุญุฐู ุขูโูุง
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        unique_lines = []
        seen = set()
        for line in code_lines:
            if line.strip() not in seen:
                unique_lines.append(line)
                seen.add(line.strip())
        if len(unique_lines) < len(code_lines):
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.writelines(unique_lines)
            logging.info("ุฎุทูุท ุชฺฉุฑุงุฑ ุญุฐู ุดุฏูุฏ ู ฺฉุฏ ุชูุฒุชุฑ ุดุฏ.")
        # ฒ. ุจุฑุฑุณ ู ูุดุฏุงุฑ ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(unique_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ณ. ูพุดููุงุฏ ุชูุณู ูุงฺูู ุงฺฏุฑ ุฎุทูุท ุฒุงุฏ ุจุงุดุฏ
        if len(unique_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ด. ุซุจุช snapshot ุฌุฏุฏ ูพุณ ุงุฒ refactor
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Refactor Snapshot {datetime.now().isoformat()} =====\n")
            logf.writelines(unique_lines)
        logging.info("โ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู ุจู ูพุงุงู ุฑุณุฏ ู snapshot ุซุจุช ุดุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู: {e}")
def self_optimize_code():
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
            code = f.read()
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []
def apply_upgrade(suggestions, current_emotion):
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")
def read_system_emotion_score():
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}
def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
def auto_apply_suggestions(suggestions, rewritten_code=None):
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                time.sleep(interval_minutes * 60)
                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                    log_upgrade_suggestion(suggestions)
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")
                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")
                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)
    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")
if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ


===== Refactor Snapshot 2025-05-29T04:28:19.523742 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)
VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"
def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")
def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")
def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    upgrades = []
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades
def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")
def auto_refactor():
        logging.info("๐ ุขุบุงุฒ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู (Refactor)...")
        # ุดุจูโุณุงุฒ ุชุญูู ุงุณุชุงุชฺฉ ฺฉุฏ ู ุจูุจูุฏ ุณุงุฎุชุงุฑ ุขู
        time.sleep(1)
        # --- ุงุฑุชูุงูุง ุฌุฏุฏ: ุชุญูู ู ูพุดููุงุฏ ุฎูุฏฺฉุงุฑ ---
        # ฑ. ุจุฑุฑุณ ุฎุทูุท ุชฺฉุฑุงุฑ ู ุญุฐู ุขูโูุง
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        unique_lines = []
        seen = set()
        for line in code_lines:
            if line.strip() not in seen:
                unique_lines.append(line)
                seen.add(line.strip())
        if len(unique_lines) < len(code_lines):
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.writelines(unique_lines)
            logging.info("ุฎุทูุท ุชฺฉุฑุงุฑ ุญุฐู ุดุฏูุฏ ู ฺฉุฏ ุชูุฒุชุฑ ุดุฏ.")
        # ฒ. ุจุฑุฑุณ ู ูุดุฏุงุฑ ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(unique_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ณ. ูพุดููุงุฏ ุชูุณู ูุงฺูู ุงฺฏุฑ ุฎุทูุท ุฒุงุฏ ุจุงุดุฏ
        if len(unique_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ด. ุซุจุช snapshot ุฌุฏุฏ ูพุณ ุงุฒ refactor
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Refactor Snapshot {datetime.now().isoformat()} =====\n")
            logf.writelines(unique_lines)
        logging.info("โ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู ุจู ูพุงุงู ุฑุณุฏ ู snapshot ุซุจุช ุดุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุจุงุฒููุณ ุฎูุฏฺฉุงุฑ ุณุณุชู: {e}")
def self_optimize_code():
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
            code = f.read()
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []
def apply_upgrade(suggestions, current_emotion):
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")
def read_system_emotion_score():
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}
def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
def auto_apply_suggestions(suggestions, rewritten_code=None):
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                time.sleep(interval_minutes * 60)
                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                    log_upgrade_suggestion(suggestions)
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")
                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")
                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)
    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")
if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ


===== Analysis Snapshot 2025-05-29T04:34:12.344722 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:34:12.852644 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:35:16.904797 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:35:17.411197 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:36:21.511909 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:36:22.683590 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:37:26.763078 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:37:27.272914 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:38:31.333352 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:38:31.844838 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:39:35.916998 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:39:36.554094 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:40:40.665281 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:40:41.174184 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:41:45.254735 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:41:45.759604 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:42:49.865934 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:42:50.374019 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:43:52.410058 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:43:52.914773 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:44:55.192988 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:44:55.700913 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:45:57.743450 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:45:58.252877 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:47:00.316309 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:47:01.911242 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:48:03.997007 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:48:04.506169 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:49:06.570318 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:49:07.080714 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)


===== Analysis Snapshot 2025-05-29T04:50:11.172046 =====
Lines: 455
Duplicates: [21, 25, 26, 35, 40, 41, 48, 53, 55, 56, 61, 63, 73, 76, 77, 80, 86, 91, 96, 98, 99, 101, 113, 145, 146, 150, 151, 152, 153, 154, 181, 183, 184, 186, 193, 194, 203, 213, 218, 220, 221, 226, 229, 230, 232, 234, 235, 243, 245, 247, 248, 250, 253, 256, 257, 259, 262, 263, 267, 270, 272, 273, 274, 276, 278, 279, 280, 281, 288, 299, 303, 314, 333, 337, 340, 346, 351, 360, 362, 363, 364, 366, 369, 370, 379, 382, 383, 389, 390, 394, 396, 397, 398, 402, 406, 408, 414, 416, 418, 427, 432, 438, 443, 446, 449, 450, 454]
LongLines: [64, 240]
Functions without docstring: ['save_version', 'log_upgrade_suggestion', 'auto_refactor', 'upgrade_scheduler', 'scheduled_task']
Long functions: []


===== Snapshot 2025-05-29T04:50:11.682207 =====
import json
import logging
import os
import shutil
import threading
import time
from datetime import datetime, timedelta
import requests  # ุงุถุงูู ุจุฑุง ุงุชุตุงู ุจู ูุฏู ููุด ูุตููุน

# ุฑุงูโุงูุฏุงุฒ logging ุฌูุช ุซุจุช ุฑูุฏุงุฏูุง
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(
            "c:\\Developer\\T13_Project\\T13\\data\\self_upgrade.log", encoding="utf-8"
        ),
        logging.StreamHandler(),
    ],
)

VERSION_FILE = "c:\\Developer\\T13_Project\\T13\\data\\version.json"
UPGRADE_LOG_FILE = "c:\\Developer\\T13_Project\\T13\\data\\upgrade_log.json"
BACKUP_DIR = "c:\\Developer\\T13_Project\\T13\\backup\\"


def backup_file(filepath):
    """ฺฉ ูุณุฎู ูพุดุชุจุงู ุงุฒ ูุงู ูุดุฎุต ุดุฏู ุงุฌุงุฏ ูโฺฉูุฏ"""
    try:
        if not os.path.exists(BACKUP_DIR):
            os.makedirs(BACKUP_DIR)
        base = os.path.basename(filepath)
        backup_path = os.path.join(
            BACKUP_DIR, f"{datetime.now().strftime('%Y%m%d_%H%M%S')}_{base}"
        )
        shutil.copy(filepath, backup_path)
        logging.info(f"๐พ ูุณุฎู ูพุดุชุจุงู {backup_path} ุงุฌุงุฏ ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุงุฏ ูุณุฎู ูพุดุชุจุงู: {e}")


def save_version(version, performance_metrics=None):
    record = {
        "version": version,
        "timestamp": datetime.now().isoformat(),
        "performance": performance_metrics or {},
    }
    try:
        backup_file(VERSION_FILE)
        with open(VERSION_FILE, "w", encoding="utf-8") as f:
            json.dump(record, f, ensure_ascii=False, indent=4)
        logging.info("ูุณุฎู ุฌุฏุฏ ุณุณุชู ุจุง ูุนุงุฑูุง ุนููฺฉุฑุฏ ุซุจุช ุดุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูุณุฎู: {e}")


def analyze_for_upgrade(internal_metrics):
    """
    ุชุญูู ูุถุนุช ุฏุงุฎู ุณุณุชู ุจุฑุง ุชุนู ูุงุฒ ุจู ุงุฑุชูุง.
    ุงุฒ ุดุงุฎุตโูุง ุณุงุฎุชุงุฑ ูุงููุฏ ูพฺุฏฺฏ ฺฉุฏุ ุฒูุงู ูพุงุณุฎฺฏู ู ฺฏุฒุงุฑุดโูุง ูุธุงุฑุช ุงุณุชูุงุฏู ูโฺฉูุฏ.
    """
    upgrades = []
    try:
        # ุดุงุฎุตโูุง ูุฑุถ ุฏุงุฎู (internal_metrics) ูโุชูุงูุฏ ุดุงูู ููุงุฑุฏ ูุซู "code_complexity"ุ "response_time" ู "error_rate" ุจุงุดุฏ.
        if internal_metrics.get("code_complexity", 0) > 7:
            upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ุจุฑุง ฺฉุงูุด ูพฺุฏฺฏ")
        if internal_metrics.get("response_time", 0) > 2:  # ุฒูุงู ูพุงุณุฎฺฏู ุจุด ุงุฒ 2 ุซุงูู
            upgrades.append("ุจูุจูุฏ ุนููฺฉุฑุฏ ุณุณุชู ุฌูุช ฺฉุงูุด ุฒูุงู ูพุงุณุฎฺฏู")
        if internal_metrics.get("error_rate", 0) > 0.1:  # ุฎุทุง ุจุดุชุฑ ุงุฒ 10 ุฏุฑุตุฏ
            upgrades.append("ุงูุฒุงุด ูุงุจูุช ุงุทููุงู ุงุฒ ุทุฑู ุจูุจูุฏ ฺฉุดู ู ุงุตูุงุญ ุฎุทุง")
        # ุญุช ุงฺฏุฑ ูุนุงุฑูุง ุฏุงุฎู ูุฑูุงู ุจุงุดุฏุ ุจูุจูุฏูุง ูพุดฺฏุฑุงูู ุงุนูุงู ุดูุฏ.
        upgrades.append("ุจูููโุณุงุฒ ุณุงุฎุชุงุฑ ฺฉุฏ ู ุงูุฒุงุด ฺฉุดู ุฎุทุง")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ูุถุนุช ุงุฑุชูุง: {e}")
    return upgrades


def log_upgrade_suggestion(suggestions):
    record = {"timestamp": datetime.now().isoformat(), "suggestions": suggestions}
    try:
        if not os.path.exists(UPGRADE_LOG_FILE):
            with open(UPGRADE_LOG_FILE, "w", encoding="utf-8") as f:
                json.dump([record], f, ensure_ascii=False, indent=4)
        else:
            with open(UPGRADE_LOG_FILE, "r+", encoding="utf-8") as f:
                try:
                    logs = json.load(f)
                    if not isinstance(logs, list):
                        logs = []
                except json.JSONDecodeError:
                    logs = []
                logs.append(record)
                f.seek(0)
                json.dump(logs, f, ensure_ascii=False, indent=4)
        logging.info("ูพุดููุงุฏุงุช ุงุฑุชูุง ุซุจุช ุดุฏูุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง: {e}")


def auto_refactor():
    try:
        logging.info("๐ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ)...")
        # ููุท ุชุญูู ู ฺฏุฒุงุฑุดุ ุจุฏูู ูฺฺฏููู ุชุบุฑ ุฏุฑ ูุงู ฺฉุฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code_lines = f.readlines()
        # ุชุญูู ุฎุทูุท ุชฺฉุฑุงุฑ
        seen = set()
        duplicate_lines = []
        for i, line in enumerate(code_lines):
            key = line.strip()
            if key in seen:
                duplicate_lines.append(i+1)
            else:
                seen.add(key)
        if duplicate_lines:
            logging.warning(f"ุฎุทูุท ุชฺฉุฑุงุฑ ุฏุฑ ฺฉุฏ (ุจุฏูู ุญุฐู): {duplicate_lines}")
        # ุชุญูู ุฎุทูุท ุจุณุงุฑ ุทููุงู
        long_lines = [i+1 for i, l in enumerate(code_lines) if len(l) > 120]
        if long_lines:
            logging.warning(f"ุฎุทูุท ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุชุญูู ุญุฌู ูุงฺูู
        if len(code_lines) > 400:
            logging.warning("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุชุญูู ุนููโุชุฑ: ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุจุณุงุฑ ุทููุงู
        in_function = False
        func_name = None
        func_start = 0
        func_lines = 0
        functions_info = []
        for idx, line in enumerate(code_lines):
            stripped = line.strip()
            if stripped.startswith('def '):
                if in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
                in_function = True
                func_name = stripped.split('def ')[1].split('(')[0].strip()
                func_start = idx
                func_lines = 1
            elif in_function:
                if stripped.startswith('def ') or stripped.startswith('class '):
                    in_function = False
                else:
                    func_lines += 1
                # ูพุงุงู ุชุงุจุน ุฏุฑ ุงูุชูุง ูุงู
                if idx == len(code_lines)-1 and in_function:
                    functions_info.append({
                        'name': func_name,
                        'start': func_start+1,
                        'lines': func_lines
                    })
        # ุดูุงุณุง ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ ู ุชูุงุจุน ุทููุงู
        funcs_no_doc = []
        long_funcs = []
        for info in functions_info:
            # ุจุฑุฑุณ ุฏุงฺฉโุงุณุชุฑูฺฏ
            docstring_found = False
            for i in range(info['start'], min(info['start']+5, len(code_lines))):
                if '"""' in code_lines[i]:
                    docstring_found = True
                    break
            if not docstring_found:
                funcs_no_doc.append(info['name'])
            if info['lines'] > 100:
                long_funcs.append((info['name'], info['lines']))
        if funcs_no_doc:
            logging.warning(f"ุชูุงุจุน ุจุฏูู ุฏุงฺฉโุงุณุชุฑูฺฏ: {funcs_no_doc}")
        if long_funcs:
            logging.warning(f"ุชูุงุจุน ุจุณุงุฑ ุทููุงู (ุจุด ุงุฒ ตฐ ุฎุท): {long_funcs}")
        # ุซุจุช ฺฏุฒุงุฑุด ุชุญูู ุฏุฑ snapshot
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Analysis Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(f"Lines: {len(code_lines)}\nDuplicates: {duplicate_lines}\nLongLines: {long_lines}\n")
            logf.write(f"Functions without docstring: {funcs_no_doc}\n")
            logf.write(f"Long functions: {long_funcs}\n")
        logging.info("โ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ ุงูุฌุงู ุดุฏ (ุจุฏูู ุชุบุฑ ุฎูุฏฺฉุงุฑ).")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุชุญูู ุณุงุฎุชุงุฑ ฺฉุฏ: {e}")


def self_optimize_code():
    """
    ุจูููโุณุงุฒ ูุงูุน: ุงุฑุชูุง ุฎูุฏ ูุงฺูู ุงุฑุชูุง (self-upgrade engine)
    - ุจุฑุฑุณ ุณูุงูุช ูุงูโูุง ูุงฺฏ ู ูุณุฎู
    - ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
    - ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
    - ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
    - ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ ูพุณ ุงุฒ ูุฑ ุงุฑุชูุง
    """
    try:
        logging.info("๐ ุดุฑูุน ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง...")
        # ุญุฐู ูุงฺฏโูุง ูุฏูโุชุฑ ุงุฒ ณฐ ุฑูุฒ
        now = datetime.now()
        removed_logs = 0
        if os.path.exists(BACKUP_DIR):
            for fname in os.listdir(BACKUP_DIR):
                fpath = os.path.join(BACKUP_DIR, fname)
                if os.path.isfile(fpath) and fname.endswith(".json"):
                    try:
                        ts = fname.split('_')[0]
                        file_time = datetime.strptime(ts, "%Y%m%d")
                        if (now - file_time).days > 30:
                            os.remove(fpath)
                            removed_logs += 1
                    except Exception:
                        continue
        # ุงุทููุงู ุงุฒ ูุฌูุฏ ูุณุฎู ูพุดุชุจุงู ุขุฎุฑู ูุณุฎู
        if os.path.exists(VERSION_FILE):
            backup_file(VERSION_FILE)
        # ุซุจุช ฺฏุฒุงุฑุด ุจูุจูุฏ
        msg = f"ูพุงฺฉุณุงุฒ {removed_logs} ูุณุฎู ูพุดุชุจุงู ูุฏู ู ุงุทููุงู ุงุฒ ุจฺฉุงูพ ูุณุฎู ูุนู ุงูุฌุงู ุดุฏ."
        logging.info(msg)
        # ุซุจุช ฺฉุฏ ฺฉุงูู ูุนู ูุงฺูู ุฏุฑ ูุงฺฏ
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_code_snapshot.log")
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Snapshot {datetime.now().isoformat()} =====\n")
            logf.write(code)
        logging.info("ฺฉุฏ ฺฉุงูู ูุงฺูู self_upgrade_engine.py ุฏุฑ ูุงฺฏ ุซุจุช ุดุฏ.")
        return [msg]
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุจูููโุณุงุฒ ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def apply_upgrade(suggestions, current_emotion):
    """
    ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ ุจูโุทูุฑ ุฎูุฏฺฉุงุฑุ ุดุงูู ุจูุจูุฏูุง ุณุณุชู ู ฺฉุฏููุณ
    """
    try:
        if suggestions:
            logging.info("๐ ุขุบุงุฒ ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ...")
            for sug in suggestions:
                logging.info(f"โค ุฏุฑ ุญุงู ุงุนูุงู ุชุบุฑ: {sug}")
                # ุฏุฑ ุงูุฌุง ูโุชูุงู ููุทู ูุงูุน ุจุฑุง ุงุนูุงู ุงุฑุชูุง (ูุงููุฏ ุจูโุฑูุฒุฑุณุงู ูพฺฉุฑุจูุฏ ุง ุชุบุฑุงุช ุฏุฑ ูุงูโูุง ูุงฺูู) ูุฑุงุฑ ุฏุงุฏ.
                time.sleep(0.5)
            logging.info("โ ุงุฑุชูุงูุง ูพุดููุงุฏ ุจุง ููููุช ุงุนูุงู ุดุฏูุฏ.")
        else:
            logging.info("โ๏ธ ูฺ ูพุดููุงุฏ ุงุฑุชูุง ุจุฑุง ุงุนูุงู ูุฌูุฏ ูุฏุงุฑุฏ.")
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุงุฑุชูุงูุง: {e}")


def read_system_emotion_score():
    """
    ุชุงุจุน ููููู ุจุฑุง ุฎูุงูุฏู ูุถุนุช ุงุญุณุงุณุงุช ุณุณุชู.
    ุฏุฑ ูุญุท ูุงูุน ุงู ุชุงุจุน ุจุงุฏ ูุถุนุช ุณุณุชู ุฑุง ุงุฒ ููุงุจุน ูุนุชุจุฑ ุจุฎูุงูุฏ.
    """
    # ููุงุฏุฑ ููููู ุฌูุช ุดุจูโุณุงุฒ
    return {"stress": 8, "hope": 3, "energy": 2}


def ai_analyze_and_rewrite(code, api_url="http://localhost:8000/ai/analyze"):
    """
    ุงุฑุณุงู ฺฉุฏ ุจู ูุฏู ููุด ูุตููุน ุจุฑุง ุชุญูู ู ุฏุฑุงูุช ูพุดููุงุฏ ุง ุจุงุฒููุณ.
    ุฎุฑูุฌ: dict ุดุงูู ูพุดููุงุฏุงุช ู (ุฏุฑ ุตูุฑุช ูุฌูุฏ) ฺฉุฏ ุจุงุฒููุณโุดุฏู
    """
    try:
        response = requests.post(api_url, json={"code": code}, timeout=30)
        if response.status_code == 200:
            return response.json()
        else:
            logging.error(f"AI API error: {response.status_code} - {response.text}")
            return {"suggestions": [], "rewritten_code": None}
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุฑุชุจุงุท ุจุง ูุฏู ููุด ูุตููุน: {e}")
        return {"suggestions": [], "rewritten_code": None}


def self_read_and_suggest(smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    """
    ูุณุฎู ุงุฑุชูุงุงูุชู: ุงฺฏุฑ smart_mode ูุนุงู ุจุงุดุฏุ ุชุญูู ู ูพุดููุงุฏุงุช ุงุฒ ูุฏู ููุด ูุตููุน ุฏุฑุงูุช ูโุดูุฏ.
    """
    try:
        with open(__file__, "r", encoding="utf-8") as f:
            code = f.read()
        suggestions = []
        ai_result = None
        long_lines = []  # ุชุนุฑู long_lines ูพุด ุงุฒ ูุฑ ุงุณุชูุงุฏู
        if smart_mode:
            ai_result = ai_analyze_and_rewrite(code, ai_api_url)
            suggestions = ai_result.get("suggestions", [])
        else:
            # ูพุดููุงุฏ: ุงฺฏุฑ ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ูุงูุต ุงุณุช
            if '"""' not in code or code.count('"""') < code.count('def '):
                suggestions.append("ุจุฑุฑุณ ู ุชฺฉูู ุฏุงฺฉโุงุณุชุฑูฺฏ ุชูุงุจุน ุจุฑุง ูุณุชูุฏุณุงุฒ ุจูุชุฑ.")
            if 'except Exception' in code and 'logging.error' not in code:
                suggestions.append("ุฏุฑ exceptูุง ุงุฒ logging.error ุจุฑุง ุซุจุช ุฎุทุง ุงุณุชูุงุฏู ุดูุฏ.")
            if 'def test_' not in code:
                suggestions.append("ุงุถุงูู ฺฉุฑุฏู ุชุณุชโูุง ูุงุญุฏ ุจุฑุง ุงุทููุงู ุงุฒ ุนููฺฉุฑุฏ ุตุญุญ ูุงฺูู.")
            if 'threading.Thread' in code and 'join' not in code:
                suggestions.append("ูุฏุฑุช ุตุญุญ ูพุงุงู threadูุง (graceful shutdown) ุงุถุงูู ุดูุฏ.")
            long_lines = [i+1 for i, l in enumerate(code.splitlines()) if len(l) > 120]
            if long_lines:
                suggestions.append(f"ฺฉุงูุด ุทูู ุฎุทูุท ุจููุฏ (ุจุด ุงุฒ ฑฒฐ ฺฉุงุฑุงฺฉุชุฑ) ุฏุฑ ุฎุทูุท: {long_lines}")
        # ุฎูุงุตู ุขูุงุฑ ุณุงุฎุชุงุฑ ฺฉุฏ
        stats = None
        try:
            functions_count = code.count('def ')
            lines_count = len(code.splitlines())
            stats = {
                'functions': functions_count,
                'classes': code.count('class '),
                'lines': lines_count,
                'try_blocks': code.count('try:'),
                'except_blocks': code.count('except'),
                'docstrings': code.count('"""'),
                'long_lines': len(long_lines),
            }
        except Exception as e_stats:
            stats = {'error': str(e_stats)}
        # ุงฺฏุฑ ูพุดููุงุฏ refactor ุณุงุฎุชุงุฑ ูุงุฒู ุจูุฏุ ุขู ุฑุง ุจู ุตูุฑุช ุฎูุฏฺฉุงุฑ ุงุถุงูู ฺฉู
        if (
            isinstance(stats, dict)
            and isinstance(stats.get('functions', 0), int)
            and isinstance(stats.get('lines', 0), int)
            and int(stats.get('functions', 0)) > 10
            and int(stats.get('lines', 0)) > 300
        ):
            suggestions.append("ูพุดููุงุฏ: ุชูุณู ูุงฺูู ุจู ฺูุฏ ูุงู ฺฉูฺฺฉุชุฑ ุจุฑุง ุฎูุงูุง ู ูฺฏูุฏุงุฑ ุจูุชุฑ.")
        # ุซุจุช ูพุดููุงุฏุงุช ู ุฎูุงุตู ุฏุฑ ูุงฺฏ
        log_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_suggestions.log")
        # ุฌููฺฏุฑ ุงุฒ ุชฺฉุฑุงุฑ ูุดุฏุงุฑูุง: ููุท ูพุดููุงุฏุงุช ุฌุฏุฏ ุฑุง ูุดุฏุงุฑ ุจุฏู
        last_suggestions = set()
        meta_path = os.path.join(os.path.dirname(__file__), "..", "data", "self_upgrade_meta.json")
        meta = {'last_run': None, 'run_count': 0, 'last_suggestions': []}
        if os.path.exists(meta_path):
            try:
                with open(meta_path, "r", encoding="utf-8") as mf:
                    meta = json.load(mf)
                    last_suggestions = set(meta.get('last_suggestions', []))
            except Exception:
                pass
        new_suggestions = [s for s in suggestions if s not in last_suggestions]
        with open(os.path.abspath(log_path), "a", encoding="utf-8") as logf:
            logf.write(f"\n\n===== Suggestions {datetime.now().isoformat()} =====\n")
            for s in suggestions:
                logf.write(f"- {s}\n")
            if stats and isinstance(stats, dict) and 'error' in stats:
                logf.write(f"\n[Code Stats Error] {stats['error']}\n")
            else:
                logf.write(f"\n[Code Stats] {stats}\n")
        # ุงฺฏุฑ ูพุดููุงุฏ ููู ุฌุฏุฏ ูุฌูุฏ ุฏุงุดุชุ ุฏุฑ ูุงฺฏ ุงุตู ูู ูุดุฏุงุฑ ุซุจุช ุดูุฏ
        if new_suggestions:
            logging.warning(f"ูพุดููุงุฏุงุช ููู ุฌุฏุฏ ุฎูุฏฺฉุฏุฎูุงู: {new_suggestions}")
        else:
            logging.info("ุฎูุฏฺฉุฏุฎูุงู: ูฺ ูพุดููุงุฏ ููู ุฌุฏุฏ ุงูุช ูุดุฏ.")
        # ุซุจุช ูุชุงุฏุชุง
        meta['last_run'] = datetime.now().isoformat()
        meta['run_count'] = meta.get('run_count', 0) + 1
        meta['last_suggestions'] = suggestions
        with open(meta_path, "w", encoding="utf-8") as mf:
            json.dump(meta, mf, ensure_ascii=False, indent=2)
        return suggestions
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุฎูุฏฺฉุฏุฎูุงู ูุงฺูู ุงุฑุชูุง: {e}")
        return []


def auto_apply_suggestions(suggestions, rewritten_code=None):
    """
    ุงฺฏุฑ ูพุดููุงุฏุงุช ูุงุจู ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุงุดูุฏ (ูุซูุงู ุฏุงฺฉโุงุณุชุฑูฺฏ ุง ุชูุณู ูุงฺูู)ุ ุขูโูุง ุฑุง ุงุนูุงู ฺฉู.
    ุงฺฏุฑ ฺฉุฏ ุจุงุฒููุณโุดุฏู ุงุฒ ูุฏู ููุด ุฏุฑุงูุช ุดุฏู ุจุงุดุฏุ ุฌุงฺฏุฒู ฺฉู.
    """
    try:
        applied = []
        if rewritten_code:
            # ุจฺฉุงูพ ู ุฌุงฺฏุฒู ฺฉุฏ
            backup_file(__file__)
            with open(__file__, "w", encoding="utf-8") as f:
                f.write(rewritten_code)
            logging.info("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุชูุณุท ูุฏู ููุด ูุตููุน ุฌุงฺฏุฒู ุดุฏ.")
            applied.append("ฺฉุฏ ุจุงุฒููุณโุดุฏู ุฌุงฺฏุฒู ุดุฏ.")
        else:
            # ููููู: ุงูุฒูุฏู ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู (ููููู ุณุงุฏู)
            if any("ุฏุงฺฉโุงุณุชุฑูฺฏ" in s for s in suggestions):
                with open(__file__, "r", encoding="utf-8") as f:
                    code = f.read()
                new_code = ""
                for line in code.splitlines():
                    new_code += line + "\n"
                    if line.strip().startswith("def ") and '"""' not in line:
                        new_code += '    """TODO: ุชูุถุญ ุชุงุจุน."""\n'
                backup_file(__file__)
                with open(__file__, "w", encoding="utf-8") as f:
                    f.write(new_code)
                applied.append("ุฏุงฺฉโุงุณุชุฑูฺฏ ุจู ุชูุงุจุน ูุงูุฏ ุขู ุงูุฒูุฏู ุดุฏ.")
        return applied
    except Exception as e:
        logging.error(f"ุฎุทุง ุฏุฑ ุงุนูุงู ุฎูุฏฺฉุงุฑ ูพุดููุงุฏุงุช: {e}")
        return []


def upgrade_scheduler(interval_minutes=10, smart_mode=False, ai_api_url="http://localhost:8000/ai/analyze"):
    def scheduled_task():
        while True:
            try:
                next_run = datetime.now() + timedelta(minutes=interval_minutes)
                logging.info(
                    f"โณ ุงุฌุฑุง ุจุนุฏ ุจุฑุฑุณ ุฏุฑ ุณุงุนุช {next_run.strftime('%H:%M:%S')}"
                )
                time.sleep(interval_minutes * 60)

                logging.info("๐ ุขุบุงุฒ ุจุฑุฑุณ ุฏูุฑูโุง ุงุฑุชูุง...")
                # ุฎูุงูุฏู ูุถุนุช ูุญุธูโุง ุณุณุชู
                current_emotion = read_system_emotion_score()
                suggestions = analyze_for_upgrade(current_emotion)
                # ุซุจุช ูพุดููุงุฏุงุช ุงุฑุชูุง ุฏุฑ ูุงู ูุงฺฏ
                if suggestions:
                    log_upgrade_suggestion(suggestions)
                else:
                    logging.info("โ ุณุณุชู ูพุงุฏุงุฑ ุงุณุชุ ุงุฑุชูุง ูุงุฒ ูุณุช.")

                # ุงุฌุฑุง ุนููุงุช ุฎูุฏฺฉุงุฑ ุงุตูุงุญ ฺฉุฏ
                auto_refactor()
                # ุงุนูุงู ุงุฑุชูุงูุง ูพุดููุงุฏ
                apply_upgrade(suggestions, current_emotion)
                # ุจูููโุณุงุฒ ุฏุงุฎู ฺฉุฏ
                code_suggestions = self_optimize_code()
                if code_suggestions:
                    logging.info("โ ุชุบุฑุงุช ุจูููโุณุงุฒ ุฏุงุฎู ุงุนูุงู ุดุฏูุฏ.")

                # ุซุจุช ูุณุฎู ุฌุฏุฏ ุจุง ูุชุฑฺฉโูุง ุณุณุชู
                save_version("T13.3_V4_Auto", performance_metrics=current_emotion)
                # ุงุฌุฑุง ุฎูุฏฺฉุงุฑ self_read_and_suggest (ููุดููุฏ)
                smart_suggestions, rewritten_code = [], None
                try:
                    result = self_read_and_suggest(smart_mode=smart_mode, ai_api_url=ai_api_url)
                    if smart_mode and isinstance(result, tuple):
                        smart_suggestions, rewritten_code = result
                    elif isinstance(result, list):
                        smart_suggestions = result
                except Exception as e:
                    logging.error(f"ุฎุทุง ุฏุฑ ุงุฌุฑุง ุฎูุฏุชุญููโฺฏุฑ ููุดููุฏ: {e}")
                # ุงุนูุงู ุฎูุฏฺฉุงุฑ ุจุฑุฎ ูพุดููุงุฏุงุช
                if smart_suggestions or rewritten_code:
                    auto_apply_suggestions(smart_suggestions, rewritten_code)
            except Exception as e:
                logging.error(f"ุฎุทุง ุฏุฑ ูุธูู ุฒูุงูโุจูุฏ ุงุฑุชูุง: {e}")
                time.sleep(5)

    threading.Thread(target=scheduled_task, daemon=True).start()
    logging.info("๐ ุฒูุงูโุจูุฏ ุงุฑุชูุง ุชูุธู ุดุฏ.")


if __name__ == "__main__":
    upgrade_scheduler(interval_minutes=1, smart_mode=True)
    # ูฺฏูโุฏุงุฑ ุจุฑูุงูู ุจุฑุง ูุดุงูุฏู ูุนุงูุชโูุง ุฒูุงูโุจูุฏ
    while True:
        time.sleep(1)
